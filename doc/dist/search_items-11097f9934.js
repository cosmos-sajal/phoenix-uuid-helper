searchNodes=[{"ref":"UuidHelperModule.html","title":"UuidHelperModule","type":"module","doc":"UuidHelperModule keeps the contexts that define your domain and business logic. Contexts are also responsible for managing your data, regardless if it comes from the database, an external API or others."},{"ref":"UuidHelperModule.Application.html","title":"UuidHelperModule.Application","type":"module","doc":""},{"ref":"UuidHelperModule.Application.html#config_change/3","title":"UuidHelperModule.Application.config_change/3","type":"function","doc":"Callback invoked after code upgrade, if the application environment has changed. changed is a keyword list of keys and their changed values in the application environment. new is a keyword list with all new keys and their values. removed is a list with all removed keys. Callback implementation for Application.config_change/3."},{"ref":"UuidHelperModule.Application.html#start/2","title":"UuidHelperModule.Application.start/2","type":"function","doc":"Called when an application is started. This function is called when an application is started using Application.start/2 (and functions on top of that, such as Application.ensure_started/2). This function should start the top-level process of the application (which should be the top supervisor of the application&#39;s supervision tree if the application follows the OTP design principles around supervision). start_type defines how the application is started: :normal - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key :start_phases is :undefined. {:takeover, node} - used if the application is distributed and is started on the current node because of a failover on the node node. {:failover, node} - used if the application is distributed and is started on the current node because of a failover on node node, and the application specification key :start_phases is not :undefined. start_args are the arguments passed to the application in the :mod specification key (e.g., mod: {MyApp, [:my_args]}). This function should either return {:ok, pid} or {:ok, pid, state} if startup is successful. pid should be the PID of the top supervisor. state can be an arbitrary term, and if omitted will default to []; if the application is later stopped, state is passed to the stop/1 callback (see the documentation for the c:stop/1 callback for more information). use Application provides no default implementation for the start/2 callback. Callback implementation for Application.start/2."},{"ref":"UuidHelperModule.Repo.html","title":"UuidHelperModule.Repo","type":"module","doc":""},{"ref":"UuidHelperModule.Repo.html#aggregate/4","title":"UuidHelperModule.Repo.aggregate/4","type":"function","doc":"Calculate the given aggregate over the given field. If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result. Any preload or select in the query will be ignored in favor of the column being aggregated. The aggregation will fail if any group_by field is set. Options See the &quot;Shared options&quot; section at the module documentation. Examples # Returns the number of visits per blog post Repo.aggregate(Post, :count, :visits) # Returns the average number of visits for the top 10 query = from Post, limit: 10 Repo.aggregate(query, :avg, :visits) Callback implementation for Ecto.Repo.aggregate/4."},{"ref":"UuidHelperModule.Repo.html#all/2","title":"UuidHelperModule.Repo.all/2","type":"function","doc":"Fetches all entries from the data store matching the given query. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query. See the &quot;Shared options&quot; section at the module documentation. Example # Fetch all post titles query = from p in Post, select: p.title MyRepo.all(query) Callback implementation for Ecto.Repo.all/2."},{"ref":"UuidHelperModule.Repo.html#child_spec/1","title":"UuidHelperModule.Repo.child_spec/1","type":"function","doc":""},{"ref":"UuidHelperModule.Repo.html#config/0","title":"UuidHelperModule.Repo.config/0","type":"function","doc":"Returns the adapter configuration stored in the :otp_app environment. If the c:init/2 callback is implemented in the repository, it will be invoked with the first argument set to :dry_run. Callback implementation for Ecto.Repo.config/0."},{"ref":"UuidHelperModule.Repo.html#delete/2","title":"UuidHelperModule.Repo.delete/2","type":"function","doc":"Deletes a struct using its primary key. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. It returns {:ok, struct} if the struct has been successfully deleted or {:error, changeset} if there was a validation or a known constraint error. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the struct. See the &quot;Shared options&quot; section at the module documentation. Example post = MyRepo.get!(Post, 42) case MyRepo.delete post do {:ok, struct} -&gt; # Deleted with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.delete/2."},{"ref":"UuidHelperModule.Repo.html#delete!/2","title":"UuidHelperModule.Repo.delete!/2","type":"function","doc":"Same as c:delete/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.delete!/2."},{"ref":"UuidHelperModule.Repo.html#delete_all/2","title":"UuidHelperModule.Repo.delete_all/2","type":"function","doc":"Deletes all entries matching the given query. It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in DELETE statements or no return result was selected, the second element will be nil. Options :returning - selects which fields to return. When true, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or false, where nothing is returned (the default). This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.delete_all(Post) from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all Callback implementation for Ecto.Repo.delete_all/2."},{"ref":"UuidHelperModule.Repo.html#get/3","title":"UuidHelperModule.Repo.get/3","type":"function","doc":"Fetches a single struct from the data store where the primary key matches the given id. Returns nil if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error. Options See the &quot;Shared options&quot; section at the module documentation. Example MyRepo.get(Post, 42) Callback implementation for Ecto.Repo.get/3."},{"ref":"UuidHelperModule.Repo.html#get!/3","title":"UuidHelperModule.Repo.get!/3","type":"function","doc":"Similar to c:get/3 but raises Ecto.NoResultsError if no record was found. Options See the &quot;Shared options&quot; section at the module documentation. Example MyRepo.get!(Post, 42) Callback implementation for Ecto.Repo.get!/3."},{"ref":"UuidHelperModule.Repo.html#get_by/3","title":"UuidHelperModule.Repo.get_by/3","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Options See the &quot;Shared options&quot; section at the module documentation. Example MyRepo.get_by(Post, title: &quot;My post&quot;) Callback implementation for Ecto.Repo.get_by/3."},{"ref":"UuidHelperModule.Repo.html#get_by!/3","title":"UuidHelperModule.Repo.get_by!/3","type":"function","doc":"Similar to get_by/3 but raises Ecto.NoResultsError if no record was found. Options See the &quot;Shared options&quot; section at the module documentation. Example MyRepo.get_by!(Post, title: &quot;My post&quot;) Callback implementation for Ecto.Repo.get_by!/3."},{"ref":"UuidHelperModule.Repo.html#in_transaction?/0","title":"UuidHelperModule.Repo.in_transaction?/0","type":"function","doc":"Returns true if the current process is inside a transaction. Examples MyRepo.in_transaction? #=&gt; false MyRepo.transaction(fn -&gt; MyRepo.in_transaction? #=&gt; true end) Callback implementation for Ecto.Repo.in_transaction?/0."},{"ref":"UuidHelperModule.Repo.html#init/2","title":"UuidHelperModule.Repo.init/2","type":"function","doc":"Dynamically loads the repository url from the DATABASE_URL environment variable."},{"ref":"UuidHelperModule.Repo.html#insert/2","title":"UuidHelperModule.Repo.insert/2","type":"function","doc":"Inserts a struct defined via Ecto.Schema or a changeset. In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset. In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database. It returns {:ok, struct} if the struct has been successfully inserted or {:error, changeset} if there was a validation or a known constraint error. Options :returning - selects which fields to return. When true, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. In any case, it will include fields with read_after_writes set to true. This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the struct. :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - Which columns to verify for conflicts. If none is specified, the conflict target is left up to the database and is usually made of primary keys and/or unique/exclusion constraints. May also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression. See the &quot;Shared options&quot; section at the module documentation. Examples A typical example is calling MyRepo.insert/1 with a struct and acting on the return value: case MyRepo.insert %Post{title: &quot;Ecto is great&quot;} do {:ok, struct} -&gt; # Inserted with success {:error, changeset} -&gt; # Something went wrong end Upserts c:insert/2 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row with the values in the excluded row (the record given in the function parameters) a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3 Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. As an example, imagine :title is marked as a unique column in the database: {:ok, inserted} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}) Now we can insert with the same title but do nothing on conflicts: {:ok, ignored} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :nothing) assert ignored.id == nil Because we used on_conflict: :nothing, instead of getting an error, we got {:ok, struct}. However the returned struct does not reflect the data in the database. One possible mechanism to detect if an insert or nothing happened in case of on_conflict: :nothing is by checking the id field. id will be nil if the field is autogenerated by the database and no insert happened. For actual upserts, where an insert or update may happen, the situation is slightly more complex, as the database does not actually inform us if an insert or update happened. Let&#39;s insert a post with the same title but use a query to update the body column in case of conflicts: # In Postgres (it requires the conflict target for updates): on_conflict = [set: [body: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict, conflict_target: :title) # In MySQL (conflict target is not supported): on_conflict = [set: [title: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{id: inserted.id, title: &quot;updated&quot;}, on_conflict: on_conflict) In the examples above, even though it returned :ok, we do not know if we inserted new data or if we updated only the :on_conflict fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as inserted_at will point to now rather than the time the struct was actually inserted. If you need to guarantee the data in the returned struct mirrors the database, you have three options: Use on_conflict: :replace_all, although that will replace all fields in the database with current ones: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :replace_all, conflict_target: :title) Specify read_after_writes: true in your schema for choosing fields that are read from the database after every operation. Or pass returning: true to insert to read all fields back: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, returning: true, on_conflict: on_conflict, conflict_target: :title) Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database: {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict) Repo.get(Post, updated.id) Because of the inability to know if the struct is up to date or not, using associations with the :on_conflict option is not recommended. For instance, Ecto may even trigger constraint violations when associations are used with on_conflict: :nothing, as no ID will be available in the case the record already exists, and it is not possible for Ecto to detect such cases reliably. Callback implementation for Ecto.Repo.insert/2."},{"ref":"UuidHelperModule.Repo.html#insert!/2","title":"UuidHelperModule.Repo.insert!/2","type":"function","doc":"Same as c:insert/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert!/2."},{"ref":"UuidHelperModule.Repo.html#insert_all/3","title":"UuidHelperModule.Repo.insert_all/3","type":"function","doc":"Inserts all entries into the repository. It expects a schema (MyApp.User) or a source (&quot;users&quot;) or both ({&quot;users&quot;, MyApp.User}) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be nil. When a schema is given, the values given will be properly dumped before being sent to the database. If the schema contains an autogenerated ID field, it will be handled either at the adapter or the storage layer. However any other autogenerated value, like timestamps, won&#39;t be autogenerated when using c:insert_all/3. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of c:insert/2. This is also consistent with c:update_all/3 that does not handle timestamps as well. It is also not possible to use insert_all to insert across multiple tables, therefore associations are not supported. If a source is given, without a schema, the given fields are passed as is to the adapter. Options :returning - selects which fields to return. When true, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or false, where nothing is returned (the default). This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - Which columns to verify for conflicts. If none is specified, the conflict target is left up to the database and is usually made of primary keys and/or unique/exclusion constraints. May also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.insert_all(Post, [[title: &quot;My first post&quot;], [title: &quot;My second post&quot;]]) MyRepo.insert_all(Post, [%{title: &quot;My first post&quot;}, %{title: &quot;My second post&quot;}]) Upserts c:insert_all/3 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row with the values in the excluded row (the corresponding record given in the function parameters) a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3 Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. Return values By default, both Postgres and MySQL return the amount of entries inserted on c:insert_all/3. However, when the :on_conflict option is specified, Postgres will only return a row if it was affected while MySQL returns at least the number of entries attempted. For example, if :on_conflict is set to :nothing, Postgres will return 0 if no new entry was added while MySQL will still return the amount of entries attempted to be inserted, even if no entry was added. Even worse, if :on_conflict is query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query. Callback implementation for Ecto.Repo.insert_all/3."},{"ref":"UuidHelperModule.Repo.html#insert_or_update/2","title":"UuidHelperModule.Repo.insert_or_update/2","type":"function","doc":"Inserts or updates a changeset depending on whether the struct is persisted or not. The distinction whether to insert or update will be made on the Ecto.Schema.Metadata field :state. The :state is automatically set by Ecto when loading or building a schema. Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won&#39;t work: struct = %Post{id: &quot;existing_id&quot;, ...} MyRepo.insert_or_update changeset # =&gt; {:error, changeset} # id already exists Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the struct. See the &quot;Shared options&quot; section at the module documentation. Example result = case MyRepo.get(Post, id) do nil -&gt; %Post{id: id} # Post not found, we build one post -&gt; post # Post exists, let&#39;s use it end |&gt; Post.changeset(changes) |&gt; MyRepo.insert_or_update case result do {:ok, struct} -&gt; # Inserted or updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.insert_or_update/2."},{"ref":"UuidHelperModule.Repo.html#insert_or_update!/2","title":"UuidHelperModule.Repo.insert_or_update!/2","type":"function","doc":"Same as c:insert_or_update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert_or_update!/2."},{"ref":"UuidHelperModule.Repo.html#load/2","title":"UuidHelperModule.Repo.load/2","type":"function","doc":"Loads data into a struct or a map. The first argument can be a schema, or a map (of types) and determines the return value: a struct or a map, respectively. The second argument data specifies fields and values that are to be loaded. It can be a map, a keyword list, or a {fields, values} tuple. Fields can be atoms or strings. Fields that are not present in the schema (or types map) are ignored. If any of the values has invalid type, an error is raised. Examples iex&gt; MyRepo.load(User, %{name: &quot;Alice&quot;, age: 25}) %User{name: &quot;Alice&quot;, age: 25} iex&gt; MyRepo.load(User, [name: &quot;Alice&quot;, age: 25]) %User{name: &quot;Alice&quot;, age: 25} data can also take form of {fields, values}: iex&gt; MyRepo.load(User, {[:name, :age], [&quot;Alice&quot;, 25]}) %User{name: &quot;Alice&quot;, age: 25, ...} The first argument can also be a types map: iex&gt; types = %{name: :string, age: :integer} iex&gt; MyRepo.load(types, %{name: &quot;Alice&quot;, age: 25}) %{name: &quot;Alice&quot;, age: 25} This function is especially useful when parsing raw query results: iex&gt; result = Ecto.Adapters.SQL.query!(MyRepo, &quot;SELECT * FROM users&quot;, []) iex&gt; Enum.map(result.rows, &amp;MyRepo.load(User, {result.columns, &amp;1})) [%User{...}, ...] Callback implementation for Ecto.Repo.load/2."},{"ref":"UuidHelperModule.Repo.html#one/2","title":"UuidHelperModule.Repo.one/2","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Raises if more than one entry. Options See the &quot;Shared options&quot; section at the module documentation. Callback implementation for Ecto.Repo.one/2."},{"ref":"UuidHelperModule.Repo.html#one!/2","title":"UuidHelperModule.Repo.one!/2","type":"function","doc":"Similar to c:one/2 but raises Ecto.NoResultsError if no record was found. Raises if more than one entry. Options See the &quot;Shared options&quot; section at the module documentation. Callback implementation for Ecto.Repo.one!/2."},{"ref":"UuidHelperModule.Repo.html#preload/3","title":"UuidHelperModule.Repo.preload/3","type":"function","doc":"Preloads all associations on the given struct or structs. This is similar to Ecto.Query.preload/3 except it allows you to preload structs after they have been fetched from the database. In case the association was already loaded, preload won&#39;t attempt to reload it. Options Besides the &quot;Shared options&quot; section at the module documentation, it accepts: :force - By default, Ecto won&#39;t preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded. :in_parallel - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to true. :prefix - the prefix to fetch preloads from. By default, queries will use the same prefix as the one in the given collection. This option allows the prefix to be changed. Examples # Use a single atom to preload an association posts = Repo.preload posts, :comments # Use a list of atoms to preload multiple associations posts = Repo.preload posts, [:comments, :authors] # Use a keyword list to preload nested associations as well posts = Repo.preload posts, [comments: [:replies, :likes], authors: []] # Use a keyword list to customize how associations are queried posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)] # Use a two-element tuple for a custom query and nested association definition query = from c in Comment, order_by: c.published_at posts = Repo.preload posts, [comments: {query, [:replies, :likes]}] Note: The query given to preload may also preload its own associations. Callback implementation for Ecto.Repo.preload/3."},{"ref":"UuidHelperModule.Repo.html#query/3","title":"UuidHelperModule.Repo.query/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query/3 for more information."},{"ref":"UuidHelperModule.Repo.html#query!/3","title":"UuidHelperModule.Repo.query!/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query/3 for more information."},{"ref":"UuidHelperModule.Repo.html#rollback/1","title":"UuidHelperModule.Repo.rollback/1","type":"function","doc":"Rolls back the current transaction. The transaction will return the value given as {:error, value}. Callback implementation for Ecto.Repo.rollback/1."},{"ref":"UuidHelperModule.Repo.html#start_link/1","title":"UuidHelperModule.Repo.start_link/1","type":"function","doc":"Starts any connection pooling or supervision and return {:ok, pid} or just :ok if nothing needs to be done. Returns {:error, {:already_started, pid}} if the repo is already started or {:error, term} in case anything else goes wrong. Options See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter&#39;s documentation. Callback implementation for Ecto.Repo.start_link/1."},{"ref":"UuidHelperModule.Repo.html#stop/2","title":"UuidHelperModule.Repo.stop/2","type":"function","doc":"Shuts down the repository represented by the given pid. Callback implementation for Ecto.Repo.stop/2."},{"ref":"UuidHelperModule.Repo.html#stream/2","title":"UuidHelperModule.Repo.stream/2","type":"function","doc":"Returns a lazy enumerable that emits all entries from the data store matching the given query. SQL adapters, such as Postgres and MySQL, can only enumerate a stream inside a transaction. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query :max_rows - The number of rows to load from the database as we stream. It is supported at least by Postgres and MySQL and defaults to 500. See the &quot;Shared options&quot; section at the module documentation. Example # Fetch all post titles query = from p in Post, select: p.title stream = MyRepo.stream(query) MyRepo.transaction(fn() -&gt; Enum.to_list(stream) end) Callback implementation for Ecto.Repo.stream/2."},{"ref":"UuidHelperModule.Repo.html#to_sql/2","title":"UuidHelperModule.Repo.to_sql/2","type":"function","doc":"A convenience function for SQL-based repositories that translates the given query to SQL. See Ecto.Adapters.SQL.query/3 for more information."},{"ref":"UuidHelperModule.Repo.html#transaction/2","title":"UuidHelperModule.Repo.transaction/2","type":"function","doc":"Runs the given function or Ecto.Multi inside a transaction. Use with function If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling c:rollback/1, this will immediately leave the function and return the value given to rollback as {:error, value}. A successful transaction returns the value returned by the function wrapped in a tuple as {:ok, value}. If c:transaction/2 is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed. Use with Ecto.Multi Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning {:ok, changes}. In case of any errors the transaction will be rolled back and {:error, failed_operation, failed_value, changes_so_far} will be returned. You can read more about using transactions with Ecto.Multi as well as see some examples in the Ecto.Multi documentation. Options See the &quot;Shared options&quot; section at the module documentation. Examples import Ecto.Changeset, only: [change: 2] MyRepo.transaction(fn -&gt; MyRepo.update!(change(alice, balance: alice.balance - 10)) MyRepo.update!(change(bob, balance: bob.balance + 10)) end) # Roll back a transaction explicitly MyRepo.transaction(fn -&gt; p = MyRepo.insert!(%Post{}) if not Editor.post_allowed?(p) do MyRepo.rollback(:posting_not_allowed) end end) # With Ecto.Multi Ecto.Multi.new |&gt; Ecto.Multi.insert(:post, %Post{}) |&gt; MyRepo.transaction Callback implementation for Ecto.Repo.transaction/2."},{"ref":"UuidHelperModule.Repo.html#update/2","title":"UuidHelperModule.Repo.update/2","type":"function","doc":"Updates a changeset using its primary key. A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the changes part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. It returns {:ok, struct} if the struct has been successfully updated or {:error, changeset} if there was a validation or a known constraint error. Options Besides the &quot;Shared options&quot; section at the module documentation, it accepts: :force - By default, if there are no changes in the changeset, c:update/2 is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps). :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the struct. Example post = MyRepo.get!(Post, 42) post = Ecto.Changeset.change post, title: &quot;New title&quot; case MyRepo.update post do {:ok, struct} -&gt; # Updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.update/2."},{"ref":"UuidHelperModule.Repo.html#update!/2","title":"UuidHelperModule.Repo.update!/2","type":"function","doc":"Same as c:update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.update!/2."},{"ref":"UuidHelperModule.Repo.html#update_all/3","title":"UuidHelperModule.Repo.update_all/3","type":"function","doc":"Updates all entries matching the given query with the given values. It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in UPDATE statements or no return result was selected, the second element will be nil. Keep in mind this update_all will not update autogenerated fields like the updated_at columns. See Ecto.Query.update/3 for update operations that can be performed on fields. Options :returning - selects which fields to return. When true, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or false, where nothing is returned (the default). This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.update_all(Post, set: [title: &quot;New title&quot;]) MyRepo.update_all(Post, inc: [visits: 1]) from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.update_all(set: [title: &quot;New title&quot;]) from(p in Post, where: p.id &lt; 10, update: [set: [title: &quot;New title&quot;]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: ^new_title]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: fragment(&quot;upper(?)&quot;, ^new_title)]]) |&gt; MyRepo.update_all([]) Callback implementation for Ecto.Repo.update_all/3."},{"ref":"UuidHelperModule.UUIDMigration.html","title":"UuidHelperModule.UUIDMigration","type":"module","doc":"Contains functions to add uuid columns to a table during migrations"},{"ref":"UuidHelperModule.UUIDMigration.html#create_index_on_uuid/1","title":"UuidHelperModule.UUIDMigration.create_index_on_uuid/1","type":"function","doc":"Adds an index on uuid column of the given table Parameters table_name: the table for which the index has to be created"},{"ref":"UuidHelperModule.UUIDMigration.html#uuid_column/0","title":"UuidHelperModule.UUIDMigration.uuid_column/0","type":"function","doc":"Adds uuid column to a table. defmodule MyApp.Repo.Migrations.CreateUser do use Ecto.Migration import Trafi.ModelHelpers.UUID.Migration def change do create table(:users) do add :email, :string add :password, :string timestamps() uuid_column() end end end"},{"ref":"UuidHelperModule.UUIDSchema.html","title":"UuidHelperModule.UUIDSchema","type":"module","doc":"Contains schema macros to add uuid fields to a schema"},{"ref":"UuidHelperModule.UUIDSchema.html#generate_uuid/0","title":"UuidHelperModule.UUIDSchema.generate_uuid/0","type":"function","doc":"Generates and return uuid"},{"ref":"UuidHelperModule.UUIDSchema.html#uuid_schema/0","title":"UuidHelperModule.UUIDSchema.uuid_schema/0","type":"macro","doc":"Adds the uuid column to a schema defmodule User do use Ecto.Schema import Trafi.ModelHelpers.UUID.Schema schema &quot;users&quot; do field :email, :string uuid_schema() end end"},{"ref":"UuidHelperModuleWeb.html","title":"UuidHelperModuleWeb","type":"module","doc":"The entrypoint for defining your web interface, such as controllers, views, channels and so on. This can be used in your application as: use UuidHelperModuleWeb, :controller use UuidHelperModuleWeb, :view The definitions below will be executed for every view, controller, etc, so keep them short and clean, focused on imports, uses and aliases. Do NOT define functions inside the quoted expressions below. Instead, define any helper function in modules and import those modules here."},{"ref":"UuidHelperModuleWeb.html#__using__/1","title":"UuidHelperModuleWeb.__using__/1","type":"macro","doc":"When used, dispatch to the appropriate controller/view/etc."},{"ref":"UuidHelperModuleWeb.html#channel/0","title":"UuidHelperModuleWeb.channel/0","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.html#controller/0","title":"UuidHelperModuleWeb.controller/0","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.html#router/0","title":"UuidHelperModuleWeb.router/0","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.html#view/0","title":"UuidHelperModuleWeb.view/0","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Endpoint.html","title":"UuidHelperModuleWeb.Endpoint","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.Endpoint.html#__sockets__/0","title":"UuidHelperModuleWeb.Endpoint.__sockets__/0","type":"function","doc":"Returns all sockets configured in this endpoint."},{"ref":"UuidHelperModuleWeb.Endpoint.html#broadcast/3","title":"UuidHelperModuleWeb.Endpoint.broadcast/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast/3."},{"ref":"UuidHelperModuleWeb.Endpoint.html#broadcast!/3","title":"UuidHelperModuleWeb.Endpoint.broadcast!/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast!/3."},{"ref":"UuidHelperModuleWeb.Endpoint.html#broadcast_from/4","title":"UuidHelperModuleWeb.Endpoint.broadcast_from/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast_from/4."},{"ref":"UuidHelperModuleWeb.Endpoint.html#broadcast_from!/4","title":"UuidHelperModuleWeb.Endpoint.broadcast_from!/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast_from!/4."},{"ref":"UuidHelperModuleWeb.Endpoint.html#call/2","title":"UuidHelperModuleWeb.Endpoint.call/2","type":"function","doc":"Callback implementation for Plug.call/2."},{"ref":"UuidHelperModuleWeb.Endpoint.html#config/2","title":"UuidHelperModuleWeb.Endpoint.config/2","type":"function","doc":"Returns the endpoint configuration for key Returns default if the key does not exist."},{"ref":"UuidHelperModuleWeb.Endpoint.html#config_change/2","title":"UuidHelperModuleWeb.Endpoint.config_change/2","type":"function","doc":"Reloads the configuration given the application environment changes."},{"ref":"UuidHelperModuleWeb.Endpoint.html#host/0","title":"UuidHelperModuleWeb.Endpoint.host/0","type":"function","doc":"Returns the host for the given endpoint."},{"ref":"UuidHelperModuleWeb.Endpoint.html#init/1","title":"UuidHelperModuleWeb.Endpoint.init/1","type":"function","doc":"Callback implementation for Plug.init/1."},{"ref":"UuidHelperModuleWeb.Endpoint.html#init/2","title":"UuidHelperModuleWeb.Endpoint.init/2","type":"function","doc":"Callback invoked for dynamically configuring the endpoint. It receives the endpoint configuration and checks if configuration should be loaded from the system environment."},{"ref":"UuidHelperModuleWeb.Endpoint.html#instrument/3","title":"UuidHelperModuleWeb.Endpoint.instrument/3","type":"macro","doc":"Instruments the given function. event is the event identifier (usually an atom) that specifies which instrumenting function to call in the instrumenter modules. runtime is metadata to be associated with the event at runtime (e.g., the query being issued if the event to instrument is a DB query). Examples instrument :render_view, %{view: &quot;index.html&quot;}, fn -&gt; render conn, &quot;index.html&quot; end"},{"ref":"UuidHelperModuleWeb.Endpoint.html#path/1","title":"UuidHelperModuleWeb.Endpoint.path/1","type":"function","doc":"Generates the path information when routing to this endpoint."},{"ref":"UuidHelperModuleWeb.Endpoint.html#script_name/0","title":"UuidHelperModuleWeb.Endpoint.script_name/0","type":"function","doc":"Generates the script name."},{"ref":"UuidHelperModuleWeb.Endpoint.html#start_link/1","title":"UuidHelperModuleWeb.Endpoint.start_link/1","type":"function","doc":"Starts the endpoint supervision tree."},{"ref":"UuidHelperModuleWeb.Endpoint.html#static_path/1","title":"UuidHelperModuleWeb.Endpoint.static_path/1","type":"function","doc":"Generates a route to a static file in priv/static."},{"ref":"UuidHelperModuleWeb.Endpoint.html#static_url/0","title":"UuidHelperModuleWeb.Endpoint.static_url/0","type":"function","doc":"Generates the static URL without any path information. It uses the configuration under :static_url to generate such. It falls back to :url if :static_url is not set."},{"ref":"UuidHelperModuleWeb.Endpoint.html#struct_url/0","title":"UuidHelperModuleWeb.Endpoint.struct_url/0","type":"function","doc":"Generates the endpoint base URL but as a URI struct. It uses the configuration under :url to generate such. Useful for manipulating the URL data and passing it to URL helpers."},{"ref":"UuidHelperModuleWeb.Endpoint.html#subscribe/1","title":"UuidHelperModuleWeb.Endpoint.subscribe/1","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Endpoint.html#subscribe/3","title":"UuidHelperModuleWeb.Endpoint.subscribe/3","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Endpoint.html#unsubscribe/1","title":"UuidHelperModuleWeb.Endpoint.unsubscribe/1","type":"function","doc":"Unsubscribes the caller from the given topic. Callback implementation for Phoenix.Endpoint.unsubscribe/1."},{"ref":"UuidHelperModuleWeb.Endpoint.html#url/0","title":"UuidHelperModuleWeb.Endpoint.url/0","type":"function","doc":"Generates the endpoint base URL without any path information. It uses the configuration under :url to generate such."},{"ref":"UuidHelperModuleWeb.ErrorHelpers.html","title":"UuidHelperModuleWeb.ErrorHelpers","type":"module","doc":"Conveniences for translating and building error messages."},{"ref":"UuidHelperModuleWeb.ErrorHelpers.html#error_tag/2","title":"UuidHelperModuleWeb.ErrorHelpers.error_tag/2","type":"function","doc":"Generates tag for inlined form input errors."},{"ref":"UuidHelperModuleWeb.ErrorHelpers.html#translate_error/1","title":"UuidHelperModuleWeb.ErrorHelpers.translate_error/1","type":"function","doc":"Translates an error message using gettext."},{"ref":"UuidHelperModuleWeb.ErrorView.html","title":"UuidHelperModuleWeb.ErrorView","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.ErrorView.html#__phoenix_recompile__?/0","title":"UuidHelperModuleWeb.ErrorView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"UuidHelperModuleWeb.ErrorView.html#__resource__/0","title":"UuidHelperModuleWeb.ErrorView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"UuidHelperModuleWeb.ErrorView.html#__templates__/0","title":"UuidHelperModuleWeb.ErrorView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"UuidHelperModuleWeb.ErrorView.html#render/2","title":"UuidHelperModuleWeb.ErrorView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"UuidHelperModuleWeb.ErrorView.html#template_not_found/2","title":"UuidHelperModuleWeb.ErrorView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"UuidHelperModuleWeb.Gettext.html","title":"UuidHelperModuleWeb.Gettext","type":"module","doc":"A module providing Internationalization with a gettext-based API. By using Gettext, your module gains a set of macros for translations, for example: import UuidHelperModuleWeb.Gettext # Simple translation gettext &quot;Here is the string to translate&quot; # Plural translation ngettext &quot;Here is the string to translate&quot;, &quot;Here are the strings to translate&quot;, 3 # Domain-based translation dgettext &quot;errors&quot;, &quot;Here is the error message to translate&quot; See the Gettext Docs for detailed usage."},{"ref":"UuidHelperModuleWeb.Gettext.html#dgettext/3","title":"UuidHelperModuleWeb.Gettext.dgettext/3","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#dgettext_noop/2","title":"UuidHelperModuleWeb.Gettext.dgettext_noop/2","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#dngettext/5","title":"UuidHelperModuleWeb.Gettext.dngettext/5","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#dngettext_noop/3","title":"UuidHelperModuleWeb.Gettext.dngettext_noop/3","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#gettext/2","title":"UuidHelperModuleWeb.Gettext.gettext/2","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#gettext_comment/1","title":"UuidHelperModuleWeb.Gettext.gettext_comment/1","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#gettext_noop/1","title":"UuidHelperModuleWeb.Gettext.gettext_noop/1","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#handle_missing_bindings/2","title":"UuidHelperModuleWeb.Gettext.handle_missing_bindings/2","type":"function","doc":"Default handling for missing bindings. This function is called when there are missing bindings in a translation. It takes a Gettext.MissingBindingsError struct and the translation with the wrong bindings left as is with the %{} syntax. For example, if something like this is called: MyApp.Gettext.gettext(&quot;Hello %{name}, welcome to %{country}&quot;, name: &quot;Jane&quot;, country: &quot;Italy&quot;) and our it/LC_MESSAGES/default.po looks like this: msgid &quot;Hello %{name}, welcome to %{country}&quot; msgstr &quot;Ciao %{name}, benvenuto in %{cowntry}&quot; # (typo) then Gettext will call: MyApp.Gettext.handle_missing_bindings(exception, &quot;Ciao Jane, benvenuto in %{cowntry}&quot;) where exception is a struct that looks like this: %Gettext.MissingBindingsError{ backend: MyApp.Gettext, domain: &quot;default&quot;, locale: &quot;it&quot;, msgid: &quot;Hello %{name}, welcome to %{country}&quot;, bindings: [:country], } The return value of the c:handle_missing_bindings/2 callback is used as the translated string that the translation macros and functions return. The default implementation for this function uses Logger.error/1 to warn about the missing binding and returns the translated message with the incomplete bindings. This function can be overridden. For example, to raise when there are missing bindings: def handle_missing_bindings(exception, _incomplete) do raise exception end Callback implementation for Gettext.Backend.handle_missing_bindings/2."},{"ref":"UuidHelperModuleWeb.Gettext.html#handle_missing_plural_translation/6","title":"UuidHelperModuleWeb.Gettext.handle_missing_plural_translation/6","type":"function","doc":"Default handling for plural translations with a missing translation. Same as c:handle_missing_translation/4, but for plural translations. In this case, n is the number used for pluralizing the translated string. Callback implementation for Gettext.Backend.handle_missing_plural_translation/6."},{"ref":"UuidHelperModuleWeb.Gettext.html#handle_missing_translation/4","title":"UuidHelperModuleWeb.Gettext.handle_missing_translation/4","type":"function","doc":"Default handling for translations with a missing translation. When a Gettext function/macro is called with a string to translate into a locale but that locale doesn&#39;t provide a translation for that string, this callback is invoked. msgid is the string that Gettext tried to translate. This function should return {:ok, translated} if a translation can be fetched or constructed for the given string, or {:default, msgid} otherwise. Callback implementation for Gettext.Backend.handle_missing_translation/4."},{"ref":"UuidHelperModuleWeb.Gettext.html#lgettext/4","title":"UuidHelperModuleWeb.Gettext.lgettext/4","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#lngettext/6","title":"UuidHelperModuleWeb.Gettext.lngettext/6","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#ngettext/4","title":"UuidHelperModuleWeb.Gettext.ngettext/4","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.Gettext.html#ngettext_noop/2","title":"UuidHelperModuleWeb.Gettext.ngettext_noop/2","type":"macro","doc":""},{"ref":"UuidHelperModuleWeb.LayoutView.html","title":"UuidHelperModuleWeb.LayoutView","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.LayoutView.html#__phoenix_recompile__?/0","title":"UuidHelperModuleWeb.LayoutView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"UuidHelperModuleWeb.LayoutView.html#__resource__/0","title":"UuidHelperModuleWeb.LayoutView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"UuidHelperModuleWeb.LayoutView.html#__templates__/0","title":"UuidHelperModuleWeb.LayoutView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"UuidHelperModuleWeb.LayoutView.html#render/2","title":"UuidHelperModuleWeb.LayoutView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"UuidHelperModuleWeb.LayoutView.html#template_not_found/2","title":"UuidHelperModuleWeb.LayoutView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"UuidHelperModuleWeb.PageController.html","title":"UuidHelperModuleWeb.PageController","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.PageController.html#index/2","title":"UuidHelperModuleWeb.PageController.index/2","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.PageView.html","title":"UuidHelperModuleWeb.PageView","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.PageView.html#__phoenix_recompile__?/0","title":"UuidHelperModuleWeb.PageView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"UuidHelperModuleWeb.PageView.html#__resource__/0","title":"UuidHelperModuleWeb.PageView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"UuidHelperModuleWeb.PageView.html#__templates__/0","title":"UuidHelperModuleWeb.PageView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"UuidHelperModuleWeb.PageView.html#render/2","title":"UuidHelperModuleWeb.PageView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"UuidHelperModuleWeb.PageView.html#template_not_found/2","title":"UuidHelperModuleWeb.PageView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"UuidHelperModuleWeb.Router.html","title":"UuidHelperModuleWeb.Router","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.Router.html#api/2","title":"UuidHelperModuleWeb.Router.api/2","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.html#browser/2","title":"UuidHelperModuleWeb.Router.browser/2","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.html#call/2","title":"UuidHelperModuleWeb.Router.call/2","type":"function","doc":"Callback invoked by Plug on every request."},{"ref":"UuidHelperModuleWeb.Router.html#init/1","title":"UuidHelperModuleWeb.Router.init/1","type":"function","doc":"Callback required by Plug that initializes the router for serving web requests."},{"ref":"UuidHelperModuleWeb.Router.Helpers.html","title":"UuidHelperModuleWeb.Router.Helpers","type":"module","doc":"Module with named helpers generated from UuidHelperModuleWeb.Router."},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#page_path/2","title":"UuidHelperModuleWeb.Router.Helpers.page_path/2","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#page_path/3","title":"UuidHelperModuleWeb.Router.Helpers.page_path/3","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#page_url/2","title":"UuidHelperModuleWeb.Router.Helpers.page_url/2","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#page_url/3","title":"UuidHelperModuleWeb.Router.Helpers.page_url/3","type":"function","doc":""},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#path/2","title":"UuidHelperModuleWeb.Router.Helpers.path/2","type":"function","doc":"Generates the path information including any necessary prefix."},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#static_path/2","title":"UuidHelperModuleWeb.Router.Helpers.static_path/2","type":"function","doc":"Generates path to a static asset given its file path."},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#static_url/2","title":"UuidHelperModuleWeb.Router.Helpers.static_url/2","type":"function","doc":"Generates url to a static asset given its file path."},{"ref":"UuidHelperModuleWeb.Router.Helpers.html#url/1","title":"UuidHelperModuleWeb.Router.Helpers.url/1","type":"function","doc":"Generates the connection/endpoint base URL without any path information."},{"ref":"UuidHelperModuleWeb.UserSocket.html","title":"UuidHelperModuleWeb.UserSocket","type":"module","doc":""},{"ref":"UuidHelperModuleWeb.UserSocket.html#connect/2","title":"UuidHelperModuleWeb.UserSocket.connect/2","type":"function","doc":"Receives the socket params and authenticates the connection. Socket params and assigns Socket params are passed from the client and can be used to verify and authenticate a user. After verification, you can put default assigns into the socket that will be set for all channels, ie {:ok, assign(socket, :user_id, verified_user_id)} To deny connection, return :error. See Phoenix.Token documentation for examples in performing token verification on connect. Callback implementation for Phoenix.Socket.connect/2."},{"ref":"UuidHelperModuleWeb.UserSocket.html#id/1","title":"UuidHelperModuleWeb.UserSocket.id/1","type":"function","doc":"Identifies the socket connection. Socket IDs are topics that allow you to identify all sockets for a given user: def id(socket), do: &quot;users_socket:\#{socket.assigns.user_id}&quot; Would allow you to broadcast a &quot;disconnect&quot; event and terminate all active sockets and channels for a given user: MyApp.Endpoint.broadcast(&quot;users_socket:&quot; &lt;&gt; user.id, &quot;disconnect&quot;, %{}) Returning nil makes this socket anonymous. Callback implementation for Phoenix.Socket.id/1."}]